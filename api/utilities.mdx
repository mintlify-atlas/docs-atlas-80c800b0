---
title: 'Utility Methods'
description: 'Printing, metadata inspection, and debugging'
---

## print

Pretty-print the data or gradient values. Formats 1D and 2D arrays in nested list form. Higher-dimensional arrays are printed in a flattened representation for brevity.

### Signature
```cpp
void print(PrintType type = PrintType::Data)
```

### Parameters
<ParamField path="type" type="PrintType">
  Selector for printing either data values or gradient values. Defaults to `PrintType::Data`.
</ParamField>

### Returns
Void. Outputs to standard output.

### Example
```cpp
// 1D array
NDArray X({5});
X.fillSequential();
X.print();
// Output: [0, 1, 2, 3, 4]

// 2D array
NDArray Y({2, 3});
Y.fillSequential();
Y.print();
// Output:
// [[0, 1, 2],
//  [3, 4, 5]]

// Print gradients
NDArray Z = Y * 2;
Z.sum().backward();
Y.print(NDArray::PrintType::Grad);
// Output:
// [[2, 2, 2],
//  [2, 2, 2]]

// 3D array (flattened output)
NDArray W({2, 2, 2});
W.fillSequential();
W.print();
// Output: [0, 1, 2, 3, 4, 5, 6, 7]
```

### Notes
- 1D arrays: printed as `[a, b, c, ...]`
- 2D arrays: printed as nested rows `[[...], [...]]`
- 3D+ arrays: printed flattened for brevity
- Uses the `PrintType` enum to select data or gradient buffer

---

## metadata

Print selected metadata fields for inspection and debugging.

### Signature
```cpp
void metadata(bool shapeInfo = true, bool stridesInfo = false,
              bool ndimInfo = false, bool sizeInfo = false,
              bool ownsDataInfo = false)
```

### Parameters
<ParamField path="shapeInfo" type="bool">
  Whether to print the shape vector. Defaults to `true`.
</ParamField>

<ParamField path="stridesInfo" type="bool">
  Whether to print the strides vector (row-major steps per axis). Defaults to `false`.
</ParamField>

<ParamField path="ndimInfo" type="bool">
  Whether to print the number of dimensions. Defaults to `false`.
</ParamField>

<ParamField path="sizeInfo" type="bool">
  Whether to print the total element count. Defaults to `false`.
</ParamField>

<ParamField path="ownsDataInfo" type="bool">
  Whether to print the memory ownership flag. Defaults to `false`.
</ParamField>

### Returns
Void. Outputs to standard output.

### Example
```cpp
NDArray X({2, 3});

// Print only shape (default)
X.metadata();
// Output: shape: [2, 3]

// Print shape and strides
X.metadata(true, true);
// Output:
// shape: [2, 3]
// strides: [3, 1]

// Print all metadata
X.metadata(true, true, true, true, true);
// Output:
// shape: [2, 3]
// strides: [3, 1]
// ndim: 2
// size: 6
// ownsData: 1

// Check if a view owns its data
NDArray view = X.slice({{0, 1}, {0, 3}});
view.metadata(true, false, false, false, true);
// Output:
// shape: [1, 3]
// ownsData: 0
```

### Notes
- Useful for debugging shape mismatches and memory ownership issues
- Strides are in elements (not bytes)
- `ownsData` is printed as `1` (true) or `0` (false)
- All parameters are optional with sensible defaults

---

## PrintType Enum

Selector enum for choosing between data and gradient buffers in print and access operations.

### Definition
```cpp
enum class PrintType { Data, Grad }
```

### Values
<ParamField path="Data" type="PrintType">
  Select the data buffer.
</ParamField>

<ParamField path="Grad" type="PrintType">
  Select the gradient buffer.
</ParamField>

### Usage
Used by:
- `print(PrintType type)`
- `get(std::vector<int> indices, PrintType type)`
- `get(int index, PrintType type)`

### Example
```cpp
NDArray X({2, 3});
X.fillSequential();

// Print data
X.print(NDArray::PrintType::Data);
// [[0, 1, 2],
//  [3, 4, 5]]

// Compute gradients
NDArray Y = X * 2;
Y.sum().backward();

// Print gradients
X.print(NDArray::PrintType::Grad);
// [[2, 2, 2],
//  [2, 2, 2]]

// Access specific gradient value
float grad = X.get({0, 0}, NDArray::PrintType::Grad);
std::cout << grad;  // 2.0
```

---

## Debugging Example

```cpp
#include "NDArray.h"
#include <iostream>

int main() {
  NDArray X({2, 3}, "my_input");
  X.fillSequential();

  std::cout << "Array label: " << X.label << std::endl;
  
  // Print full metadata
  X.metadata(true, true, true, true, true);
  
  // Print data
  std::cout << "\nData:" << std::endl;
  X.print();
  
  // Perform operation
  NDArray Y = X * 2;
  std::cout << "\nOperation: " << Y.op << std::endl;
  
  // Trigger backprop
  Y.sum().backward();
  
  // Print gradients
  std::cout << "\nGradients:" << std::endl;
  X.print(NDArray::PrintType::Grad);
  
  // Create a view and check ownership
  NDArray view = X.slice({{0, 1}, {0, 3}});
  std::cout << "\nView metadata:" << std::endl;
  view.metadata(true, true, false, false, true);
  
  return 0;
}
```
