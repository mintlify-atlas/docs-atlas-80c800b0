---
title: Introduction
description: A minimal NumPy-like N-dimensional float array library in C++ with autograd support
---

# Welcome to IncliArray

IncliArray is a minimal, readable N-dimensional float array library for C++ that brings NumPy-style array operations to your C++ projects. With built-in automatic differentiation (autograd), it's perfect for learning neural network fundamentals or building lightweight machine learning experiments.

## Why IncliArray?

IncliArray focuses on clarity and concepts over performance. The entire implementation spans just two files (one header + one source), making it an excellent educational resource and a practical tool for rapid prototyping.

<CardGroup cols={2}>
  <Card title="N-dimensional arrays" icon="cube">
    Row-major float arrays with explicit shapes and strides, just like NumPy
  </Card>
  
  <Card title="Broadcasting arithmetic" icon="calculator">
    Element-wise operations with automatic broadcasting for arrays and scalars
  </Card>
  
  <Card title="Automatic differentiation" icon="chart-network">
    Lightweight reverse-mode autograd for building and training neural networks
  </Card>
  
  <Card title="Views and slicing" icon="scissors">
    Memory-efficient array slicing with non-owning views
  </Card>
  
  <Card title="Array reshaping" icon="shapes">
    Reshape contiguous arrays without copying data
  </Card>
  
  <Card title="Matrix operations" icon="matrix">
    2D matrix multiplication and reduction operations along any axis
  </Card>
</CardGroup>

## Quick example

Here's a taste of what you can do with IncliArray:

```cpp
#include <NDArray.h>
#include <iostream>

int main() {
  // Create a 2x3 matrix
  NDArray A({2, 3});
  A.fillSequential();  // [0, 1, 2, 3, 4, 5]

  // Create a 1x3 row vector
  NDArray B({1, 3});
  B.ones();  // [1, 1, 1]

  // Broadcasting add and scalar operations
  NDArray C = A + B;
  NDArray D = C.element_wise_multiply(2.0f);
  NDArray E = D - 3.0f;

  // Matrix multiplication
  NDArray W({3, 2});
  W.randint(1, 5);
  NDArray G = A * W;  // (2x3) * (3x2) = (2x2)

  // Autograd: compute sum and backpropagate
  NDArray S = G.sum();
  S.backward();

  // View gradients
  std::cout << "Grad A:" << std::endl;
  A.print(NDArray::PrintType::Grad);
}
```

## Key features

### Array operations
- **Initialization**: `zeros()`, `ones()`, `fill()`, `fillSequential()`
- **Random generation**: `randint(low, high)`, `rand()`, `rand(low, high)`
- **Element access**: Multi-dimensional `get/set(indices)` or flat `get/set(index)`
- **Reshaping**: `reshape(newShape)` for contiguous arrays
- **Slicing**: `slice()` returns non-owning views
- **Cloning**: `clone()` creates owning copies

### Arithmetic operations
- **Broadcasting**: `+`, `-`, `/`, `element_wise_multiply()` between arrays
- **Scalar operations**: `+ float`, `- float`, `/ float`, `* float`
- **Power**: `operator^(float)` for element-wise exponentiation
- **Matrix multiplication**: `operator*` for 2D arrays
- **Reductions**: `sum()` for all elements, `sum(axis)` for specific dimension

### Automatic differentiation
- Results from operations automatically build a computation graph
- Call `backward()` on any output to accumulate gradients
- Gradients are stored in the `grad` buffer of each array
- Supports all core operations: add, subtract, multiply, divide, matmul, power, sum

## Get started

<CardGroup cols={2}>
  <Card title="Installation" icon="download" href="/installation">
    Install IncliArray using CMake in just a few minutes
  </Card>
  
  <Card title="Quick start" icon="rocket" href="/quickstart">
    Build your first array program and learn the basics
  </Card>
</CardGroup>
